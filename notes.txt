-->Golang is compiled, JAVA is not a compiled language, it is in between, it gives some intermediate binaries and expects us to have the virtual machine installed called JVM.
-->go tool can run file directly, without VM.
-->Executables are different for OS

-->WHAT IS GOLANG USED FOR?
system apps to web apps
it is already in production

-->Don't bring baggage with this language, the purpose of making this languge was entirely different

==>IS GO object orientee?
YES AND NO
-->it don't have classes, it have structs(structs are alternatives of classes)_.
-->dont have overloading.

==>lexer does a lot of work, it autocompletes our code.
->What is the reason for language designers to even start working on getting rid of tokens like semicolons? The answer is quite simple. It’s all about readability. The less artefacts code has, the easier it’s to work with. It’s important since once written piece of code will be probably read many times by different people.

Grammar uses semicolons as productions terminators. Since the goal is to free programmer from typing these semicolons, there must be a way to automatically inject them. This is what Go’s lexer is doing. Semicolon is added when line’s last token is one of:

    an identifier
    an integer, floating-point, imaginary, rune, or string literal
    one of the keywords break, continue, fallthrough, or return
    one of the operators and delimiters ++, --, ), ], or }

fmt.Println --> P is capital in this, this Println function was exported publicaly for open use

-->Variable should be known in advance.

-->everything in golang is a type.

==>TYPES:-
STRING
BOOL
INTEGER --> uint8 uint64 int8 int64 uintptr (aliases are involved too)
FLOATING --> float32 float64
COMPLEX
ARRAY
SLICES
MAPS
STRUCTS
POINTERS

uint will have only non negative numbers. BUT int will have both positive and negative numbers.

aliases --> Alias is a second name for an exising type and it's just like replacing all occurences of int1 with int.
1. byte --> A byte takes 8 bits of storage. In Go, it is equivalent to the data type uint8. It is used to represent an ASCII character.

2. rune --> A rune takes 4 bytes or 32 bits for storage. It is an int32 equivalent. Runes are used to represent the Unicode characters, which is a broader set than ASCII characters. These Unicode characters are encoded in the UTF-8 format. 

==> %c is used to print character

==>if we just initialise a type then it is assigned 0(for integer), it is not assigned a garbage value.

-->inside a method walurus operator :=  can be used but not in the global scope

TIME:- for formating the time in proper way, we need to use these values only
fmt.Println(createdDate.Format("01-02-2006 Monday January 15.04.05"))

==>Making executables for linux, windows, darwin.
GOOS="darwin" go build
GOOS="linux" go build
GOOS="windows" go build

MEMORY MANAGEMENT IN GO:
==>memory allocation and deallocation happens automatically.
new()
allocate memory but no INIT
you will get a memory address
zeroed storage --> we can't put data inside it

make()
Allocate memory and INIT
you will get a memory address
non-zeroed storage --> we can put data inside it

GARBAGE COLLECTION OVERVIEW:-

1. The Go language takes responsibility for arranging the storage of Go values; in most cases, a Go developer need not care about where these values are stored, or why, if at all. In practice, however, these values often need to be stored in computer physical memory and physical memory is a finite resource. Because it is finite, memory must be managed carefully and recycled in order to avoid running out of it while executing a Go program. It's the job of a Go implementation to allocate and recycle memory as needed.

2.Another term for automatically recycling memory is garbage collection. At a high level, a garbage collector (or GC, for short) is a system that recycles memory on behalf of the application by identifying which parts of memory are no longer needed. The Go standard toolchain provides a runtime library that ships with every application, and this runtime library includes a garbage collector.

3.The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely.  
